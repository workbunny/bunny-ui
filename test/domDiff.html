<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 虚拟DOM节点
        class VNode {
            /**
             * 
             * @param {*} tag 标签名
             * @param {*} attrs 属性
             * @param {*} children 子节点
             * @param {*} key 唯一标识
             * @param {*} el 真实DOM节点
             */
            constructor(tag, attrs = {}, children = [], key = null, el = null) {
                this.tag = tag;
                this.attrs = attrs;
                this.children = children;
                this.key = key;
                this.el = el;
            }
        }

        // 将DOM节点转换为虚拟DOM节点
        function domToVNode(dom) {
            let VNodeArray = [];
            dom.forEach((node, index) => {
                const tag = node.nodeName.toLowerCase();
                const attrs = {};
                if (node.attributes) {
                    for (let i = 0; i < node.attributes.length; i++) {
                        const attr = node.attributes[i];
                        attrs[attr.name] = attr.value;
                    }
                }

                // 处理子节点
                const children = domToVNode(node.childNodes);

                if (tag === '#text') {
                    VNodeArray.push(node.textContent)
                } else {
                    VNodeArray.push(new VNode(
                        tag,
                        attrs,
                        children,
                        index,
                        node
                    ));
                }
            });
            return VNodeArray;
        }

        // 解析HTML字符串为DOM节点
        function parseHTML(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString.trim();
            return tempDiv.childNodes;
        }

        // HTML字符串示例
        const html1 = `
            <div id="app">
                <div class="card">
                    <img src="https://picsum.photos/200/300" alt="图片">
                    <button disabled>提交</button>
                </div>
                <span>旧卡片内容</span>
            </div>
            <span>111</span>
        `;

        const html2 = `
            <div id="app">
                <div class="card">
                    <img src="https://picsum.photos/200/300" alt="图片">
                    <button>提交</button>
                </div>
                <span>新卡片内容</span>
                <span>222</span>
            </div>
            <span>333</span>
        `;

        // 生成虚拟DOM
        const dom1 = parseHTML(html1);
        const dom2 = parseHTML(html2);
        const VNodeArray1 = domToVNode(dom1);
        const VNodeArray2 = domToVNode(dom2);

        function diff(oldVNodes, newVNodes) {
            const patches = [];
            let index = 0;

            // 首先遍历两个节点数组，找出更新和删除的节点
            for (let i = 0; i < oldVNodes.length; i++) {
                const oldNode = oldVNodes[i];
                const newNode = newVNodes[i];

                // 如果节点不存在，说明被删除了
                if (!newNode) {
                    patches.push({
                        type: 'REMOVE',
                        index: i,
                        node: oldNode
                    });
                    continue;
                }

                // 文本节点比较
                if (typeof oldNode === 'string' || typeof newNode === 'string') {
                    if (oldNode !== newNode) {
                        patches.push({
                            type: 'UPDATE',
                            index: i,
                            oldNode: oldNode,
                            newNode: newNode
                        });
                    }
                    continue;
                }

                // 标签名不同，直接替换
                if (oldNode.tag !== newNode.tag) {
                    patches.push({
                        type: 'REPLACE',
                        index: i,
                        oldNode: oldNode,
                        newNode: newNode
                    });
                    continue;
                }

                // 比较属性
                const attrsPatches = diffAttrs(oldNode.attrs, newNode.attrs);
                if (Object.keys(attrsPatches).length > 0) {
                    patches.push({
                        type: 'ATTR',
                        index: i,
                        attrs: attrsPatches
                    });
                }

                // 递归比较子节点
                const childrenPatches = diff(oldNode.children, newNode.children);
                if (childrenPatches.length > 0) {
                    patches.push({
                        type: 'CHILDREN',
                        index: i,
                        patches: childrenPatches
                    });
                }
            }

            // 检查新增的节点
            for (let i = oldVNodes.length; i < newVNodes.length; i++) {
                patches.push({
                    type: 'ADD',
                    index: i,
                    node: newVNodes[i]
                });
            }

            return patches;
        }

        // 比较属性差异
        function diffAttrs(oldAttrs, newAttrs) {
            const patches = {};

            // 检查更改和新增的属性
            for (let key in newAttrs) {
                if (oldAttrs[key] !== newAttrs[key]) {
                    patches[key] = newAttrs[key];
                }
            }

            // 检查删除的属性
            for (let key in oldAttrs) {
                if (!newAttrs.hasOwnProperty(key)) {
                    patches[key] = undefined;
                }
            }

            return patches;
        }

        // 应用补丁到真实DOM
        function applyPatches(node, patches) {
            patches.forEach(patch => {
                switch (patch.type) {
                    case 'ADD':
                        addNode(node, patch.index, patch.node);
                        break;
                    case 'REMOVE':
                        removeNode(node, patch.index, patch.node);
                        break;
                    case 'UPDATE':
                        updateNode(node, patch.index, patch.oldNode, patch.newNode);
                        break;
                    case 'REPLACE':
                        replaceNode(node, patch.index, patch.oldNode, patch.newNode);
                        break;
                    case 'ATTR':
                        updateAttrs(node, patch.index, patch.attrs);
                        break;
                    case 'CHILDREN':
                        applyPatches(node.childNodes[patch.index], patch.patches);
                        break;
                }
            });
        }

        // 添加节点
        function addNode(parent, index, newNode) {
            const el = createElement(newNode);
            if (index >= parent.childNodes.length) {
                parent.appendChild(el);
            } else {
                parent.insertBefore(el, parent.childNodes[index]);
            }
        }

        // 删除节点
        function removeNode(parent, index, node) {
            if (parent.childNodes[index]) {
                parent.removeChild(parent.childNodes[index]);
            }
        }

        // 更新节点（文本节点）
        function updateNode(parent, index, oldNode, newNode) {
            if (parent.childNodes[index]) {
                parent.childNodes[index].textContent = newNode;
            }
        }

        // 替换节点
        function replaceNode(parent, index, oldNode, newNode) {
            if (parent.childNodes[index]) {
                const el = createElement(newNode);
                parent.replaceChild(el, parent.childNodes[index]);
            }
        }

        // 更新属性
        function updateAttrs(parent, index, attrs) {
            const node = parent.childNodes[index];
            if (!node) return;

            for (let key in attrs) {
                if (attrs[key] === undefined) {
                    node.removeAttribute(key);
                } else {
                    node.setAttribute(key, attrs[key]);
                }
            }
        }

        // 根据虚拟节点创建真实DOM元素
        function createElement(vnode) {
            if (typeof vnode === 'string') {
                return document.createTextNode(vnode);
            }

            const el = document.createElement(vnode.tag);

            // 设置属性
            for (let key in vnode.attrs) {
                el.setAttribute(key, vnode.attrs[key]);
            }

            // 递归创建子节点
            vnode.children.forEach(child => {
                el.appendChild(createElement(child));
            });

            return el;
        }
    </script>
</body>

</html>